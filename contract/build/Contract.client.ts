/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.20.0.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
import {ApiVersion, Binary, SupportedSectorSize, Addr, PoseidonDomain, Sha256Domain, VerifierParameters, SetupParams, LayerChallenges, PublicInputsForPoseidonDomainAndSha256Domain, TauForPoseidonDomainAndSha256Domain, ArrayOfString, Int32, Boolean} from "./types";
import {InstantiateMsg, ExecuteMsg, QueryMsg, CurrentRoundResponse} from "./Contract.types";
export interface ContractReadOnlyInterface {
  contractAddress: string;
  queryRoundCurrent: () => Promise<CurrentRoundResponse>;
  queryUserReward: ({
    user
  }: {
    user: string;
  }) => Promise<Int32>;
  queryListUser: ({
    lastValue,
    limit
  }: {
    lastValue?: string;
    limit: number;
  }) => Promise<ArrayOfString>;
  verifyProof: ({
    apiVersion,
    porepId,
    proofRaw,
    proverId,
    publicInputs,
    sectorId,
    sectorSize,
    ticket
  }: {
    apiVersion: ApiVersion;
    porepId: Binary;
    proofRaw: Binary;
    proverId: Binary;
    publicInputs: PublicInputsForPoseidonDomainAndSha256Domain;
    sectorId: number;
    sectorSize: SupportedSectorSize;
    ticket: Binary;
  }) => Promise<Boolean>;
}
export class ContractQueryClient implements ContractReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.queryRoundCurrent = this.queryRoundCurrent.bind(this);
    this.queryUserReward = this.queryUserReward.bind(this);
    this.queryListUser = this.queryListUser.bind(this);
    this.verifyProof = this.verifyProof.bind(this);
  }

  queryRoundCurrent = async (): Promise<CurrentRoundResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_round_current: {}
    });
  };
  queryUserReward = async ({
    user
  }: {
    user: string;
  }): Promise<Int32> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_user_reward: {
        user
      }
    });
  };
  queryListUser = async ({
    lastValue,
    limit
  }: {
    lastValue?: string;
    limit: number;
  }): Promise<ArrayOfString> => {
    return this.client.queryContractSmart(this.contractAddress, {
      query_list_user: {
        last_value: lastValue,
        limit
      }
    });
  };
  verifyProof = async ({
    apiVersion,
    porepId,
    proofRaw,
    proverId,
    publicInputs,
    sectorId,
    sectorSize,
    ticket
  }: {
    apiVersion: ApiVersion;
    porepId: Binary;
    proofRaw: Binary;
    proverId: Binary;
    publicInputs: PublicInputsForPoseidonDomainAndSha256Domain;
    sectorId: number;
    sectorSize: SupportedSectorSize;
    ticket: Binary;
  }): Promise<Boolean> => {
    return this.client.queryContractSmart(this.contractAddress, {
      verify_proof: {
        api_version: apiVersion,
        porep_id: porepId,
        proof_raw: proofRaw,
        prover_id: proverId,
        public_inputs: publicInputs,
        sector_id: sectorId,
        sector_size: sectorSize,
        ticket
      }
    });
  };
}
export interface ContractInterface extends ContractReadOnlyInterface {
  contractAddress: string;
  sender: string;
  setVerifierParams: ({
    duration,
    params,
    sectorSize
  }: {
    duration: number;
    params: VerifierParameters;
    sectorSize: SupportedSectorSize;
  }, $fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
  setOwner: ({
    newOwner
  }: {
    newOwner: Addr;
  }, $fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
  submitProof: ({
    apiVersion,
    porepId,
    proofRaw,
    proverId,
    publicInputs,
    sectorId,
    sectorSize,
    ticket
  }: {
    apiVersion: ApiVersion;
    porepId: Binary;
    proofRaw: Binary;
    proverId: Binary;
    publicInputs: PublicInputsForPoseidonDomainAndSha256Domain;
    sectorId: number;
    sectorSize: SupportedSectorSize;
    ticket: Binary;
  }, $fee?: number | StdFee | "auto", $memo?: string, $funds?: Coin[]) => Promise<ExecuteResult>;
}
export class ContractClient extends ContractQueryClient implements ContractInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.setVerifierParams = this.setVerifierParams.bind(this);
    this.setOwner = this.setOwner.bind(this);
    this.submitProof = this.submitProof.bind(this);
  }

  setVerifierParams = async ({
    duration,
    params,
    sectorSize
  }: {
    duration: number;
    params: VerifierParameters;
    sectorSize: SupportedSectorSize;
  }, $fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_verifier_params: {
        duration,
        params,
        sector_size: sectorSize
      }
    }, $fee, $memo, $funds);
  };
  setOwner = async ({
    newOwner
  }: {
    newOwner: Addr;
  }, $fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_owner: {
        new_owner: newOwner
      }
    }, $fee, $memo, $funds);
  };
  submitProof = async ({
    apiVersion,
    porepId,
    proofRaw,
    proverId,
    publicInputs,
    sectorId,
    sectorSize,
    ticket
  }: {
    apiVersion: ApiVersion;
    porepId: Binary;
    proofRaw: Binary;
    proverId: Binary;
    publicInputs: PublicInputsForPoseidonDomainAndSha256Domain;
    sectorId: number;
    sectorSize: SupportedSectorSize;
    ticket: Binary;
  }, $fee: number | StdFee | "auto" = "auto", $memo?: string, $funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      submit_proof: {
        api_version: apiVersion,
        porep_id: porepId,
        proof_raw: proofRaw,
        prover_id: proverId,
        public_inputs: publicInputs,
        sector_id: sectorId,
        sector_size: sectorSize,
        ticket
      }
    }, $fee, $memo, $funds);
  };
}