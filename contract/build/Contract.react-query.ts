/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.20.0.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { UseQueryOptions, useQuery, useMutation, UseMutationOptions } from "@tanstack/react-query";
import { ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee, Coin } from "@cosmjs/amino";
import {ApiVersion, Binary, SupportedSectorSize, Addr, PoseidonDomain, Sha256Domain, VerifierParameters, SetupParams, LayerChallenges, PublicInputsForPoseidonDomainAndSha256Domain, TauForPoseidonDomainAndSha256Domain, ArrayOfString, Int32, Boolean} from "./types";
import {InstantiateMsg, ExecuteMsg, QueryMsg, CurrentRoundResponse} from "./Contract.types";
import { ContractQueryClient, ContractClient } from "./Contract.client";
export interface ContractReactQuery<TResponse, TData = TResponse> {
  client: ContractQueryClient | undefined;
  options?: Omit<UseQueryOptions<TResponse, Error, TData>, "'queryKey' | 'queryFn' | 'initialData'"> & {
    initialData?: undefined;
  };
}
export interface ContractVerifyProofQuery<TData> extends ContractReactQuery<Boolean, TData> {
  args: {
    apiVersion: ApiVersion;
    porepId: Binary;
    proofRaw: Binary;
    proverId: Binary;
    publicInputs: PublicInputsForPoseidonDomainAndSha256Domain;
    sectorId: number;
    sectorSize: SupportedSectorSize;
    ticket: Binary;
  };
}
export function useContractVerifyProofQuery<TData = Boolean>({
  client,
  args,
  options
}: ContractVerifyProofQuery<TData>) {
  return useQuery<Boolean, Error, TData>(["contractVerifyProof", client?.contractAddress, JSON.stringify(args)], () => client ? client.verifyProof({
    apiVersion: args.apiVersion,
    porepId: args.porepId,
    proofRaw: args.proofRaw,
    proverId: args.proverId,
    publicInputs: args.publicInputs,
    sectorId: args.sectorId,
    sectorSize: args.sectorSize,
    ticket: args.ticket
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface ContractQueryListUserQuery<TData> extends ContractReactQuery<ArrayOfString, TData> {
  args: {
    lastValue?: string;
    limit: number;
  };
}
export function useContractQueryListUserQuery<TData = ArrayOfString>({
  client,
  args,
  options
}: ContractQueryListUserQuery<TData>) {
  return useQuery<ArrayOfString, Error, TData>(["contractQueryListUser", client?.contractAddress, JSON.stringify(args)], () => client ? client.queryListUser({
    lastValue: args.lastValue,
    limit: args.limit
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface ContractQueryUserRewardQuery<TData> extends ContractReactQuery<Int32, TData> {
  args: {
    user: string;
  };
}
export function useContractQueryUserRewardQuery<TData = Int32>({
  client,
  args,
  options
}: ContractQueryUserRewardQuery<TData>) {
  return useQuery<Int32, Error, TData>(["contractQueryUserReward", client?.contractAddress, JSON.stringify(args)], () => client ? client.queryUserReward({
    user: args.user
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface ContractQueryRoundCurrentQuery<TData> extends ContractReactQuery<CurrentRoundResponse, TData> {}
export function useContractQueryRoundCurrentQuery<TData = CurrentRoundResponse>({
  client,
  options
}: ContractQueryRoundCurrentQuery<TData>) {
  return useQuery<CurrentRoundResponse, Error, TData>(["contractQueryRoundCurrent", client?.contractAddress], () => client ? client.queryRoundCurrent() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface ContractSubmitProofMutation {
  client: ContractClient;
  msg: {
    apiVersion: ApiVersion;
    porepId: Binary;
    proofRaw: Binary;
    proverId: Binary;
    publicInputs: PublicInputsForPoseidonDomainAndSha256Domain;
    sectorId: number;
    sectorSize: SupportedSectorSize;
    ticket: Binary;
  };
  args?: {
    $fee?: number | StdFee | "auto";
    $memo?: string;
    $funds?: Coin[];
  };
}
export function useContractSubmitProofMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, ContractSubmitProofMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, ContractSubmitProofMutation>(({
    client,
    msg,
    args: {
      $fee,
      $memo,
      $funds
    } = {}
  }) => client.submitProof(msg, $fee, $memo, $funds), options);
}
export interface ContractSetOwnerMutation {
  client: ContractClient;
  msg: {
    newOwner: Addr;
  };
  args?: {
    $fee?: number | StdFee | "auto";
    $memo?: string;
    $funds?: Coin[];
  };
}
export function useContractSetOwnerMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, ContractSetOwnerMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, ContractSetOwnerMutation>(({
    client,
    msg,
    args: {
      $fee,
      $memo,
      $funds
    } = {}
  }) => client.setOwner(msg, $fee, $memo, $funds), options);
}
export interface ContractSetVerifierParamsMutation {
  client: ContractClient;
  msg: {
    duration: number;
    params: VerifierParameters;
    sectorSize: SupportedSectorSize;
  };
  args?: {
    $fee?: number | StdFee | "auto";
    $memo?: string;
    $funds?: Coin[];
  };
}
export function useContractSetVerifierParamsMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, ContractSetVerifierParamsMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, ContractSetVerifierParamsMutation>(({
    client,
    msg,
    args: {
      $fee,
      $memo,
      $funds
    } = {}
  }) => client.setVerifierParams(msg, $fee, $memo, $funds), options);
}